use crate::profiles::profile_options::ProfileOptions;
use crate::wow::wow_hook::WowCheats;
use crate::xml_library::xml_handler::PROFILE_SIZE;

/// Return string of a pre-start-up information for the bot to function
pub fn pqr_pre_start_up(show_chat: bool, enable_debug: bool, require_combat: bool, rotation_designation: bool, refresh_rate: f32, interrupt_delay: f32) -> String {
    // Setup return string and add all the necessary initialisers
    let mut return_string = format!(
        " PQR_ShowChat = {show_chat} \
          PQR_DebugEnabled = {enable_debug} \
          PQR_RequireCombat = {require_combat} \
          PQR_RotationDesignation = {rotation_designation} \
          PQR_StartRotationSound = \"PAPERDOLLOPEN\" \
          PQR_ChangeRotationSound = \"SHEATHINGSHIELDUNSHEATHE\" \
          PQR_StopRotationSound = \"PAPERDOLLCLOSE\" \
          PQR_StartInterruptSound = \"igAbilityOpen\" \
          PQR_StopInterruptSound = \"igAbilityClose\" \
        "
    );
    // Set refresh rate
    if refresh_rate >= 20. && refresh_rate <= 1000. {
        return_string = format!("{return_string} PQR_ChangeInterval({refresh_rate})");
    }
    else {
        return_string = format!("{return_string} PQR_ChangeInterval(100)");
    }
    // Set interrupt delay
    if interrupt_delay > 0. && interrupt_delay < 1000. {
        return_string = format!("{return_string} PQR_InterruptDelay = {interrupt_delay}");
    }
    else {
        return_string = format!("{return_string} PQR_InterruptDelay = 0");
    }
    // Return info
    return_string
}
// Return string of a start up information for the bot
pub fn start_op_bot(enable_interrupt: bool, interrupt_mode_change : bool, interrupt_all: bool, smart_key_mode: bool, change_rotation: bool, rotation_name: String) -> String {
    let mut return_string = format!(" PQR_InterruptAllSpells = {interrupt_all}");
    if !enable_interrupt {
        return_string = format!("{return_string} PQR_EnableInterrupt(true)");
    }
    else if interrupt_mode_change {
        return_string = format!("{return_string} PQR_EnableInterrupt()");
    }
    if change_rotation {
        return_string = format!("{return_string} PQR_ManualMode = {smart_key_mode}");
        // no rotation passed
        if rotation_name.is_empty() {
            return_string = format!("{return_string} PQR_EnableBot(\"\")");
        }
        // Manual mode passed
        else if rotation_name == "* Manual" {
            return_string = format!("{return_string} PQR_EnableBot(\"{rotation_name}\")");
        }
        // Parse rotation
        else {
            let parsed_name = rotation_name
                .get(rotation_name.rfind("(").map_or(rotation_name.len(), |pos| pos + 1)..rotation_name.rfind(")").unwrap_or(rotation_name.len()))
                .unwrap_or_default()
                .to_string();
            let second_parsed_name = rotation_name
                .get(..rotation_name.rfind(" (").unwrap_or(rotation_name.len()))
                .unwrap_or_default()
                .to_string();
            return_string = format!("{return_string} PQR_EnableBot(\"{second_parsed_name}^&*{parsed_name}\")");
        }
    }
    return_string
}
/// Return a string which has the information to cast the next func
pub fn cast_next_func(inp_func_name: String) -> String {
    let func_name = inp_func_name.as_str().replace(" ", "");
    // Check if func name is empty
    if func_name.is_empty() {
        return "nil".to_string();
    }
    // Return string
    "\r\n                SetCVar(\"violenceLevel\", 2)\r\n\r\n                function %FNAME%(castNextRotation)\r\n                    if castNextRotation ~= nil then\r\n                        if tonumber(castNextRotation) ~= nil then\r\n                            SetCVar(\"violenceLevel\", castNextRotation + 5)\r\n                        end\r\n                    end\r\n                end".replace("%FNAME%", func_name.as_str()).to_string()
}
/// Return a string to add an ability
pub fn add_ability(rotation_number: String, index: String, spell_id: String, action: String, test_code: String, recast_delay: String, target_cast: String, cancel_channel: String, lua_before: String, lua_after: String) -> String {
    let func_string = format!("function pqrFunc{index}() {test_code} end");
    let func_before_string = format!(" function pqrFuncBefore{index}() {lua_before} end");
    let func_after_string = format!(" function pqrFuncAfter{index}() {lua_after} end");
    let add_ability_string = format!("PQR_AddAbility(\
    {rotation_number}, \
    {index}, \
    {spell_id}, \"\
    {action}\", pqrFunc\
    {index}, \
    {recast_delay}, \"\
    {target_cast}\", \
    {cancel_channel}, pqrFuncBefore\
    {index}, pqrFuncAfter\
    {index})");

    format!("{func_string} {func_before_string} {func_after_string} {add_ability_string}")
}
/// Return bool if rotation requires combat
pub fn rotation_requires_combat(rotation_array: Vec<Vec<String>>, rotation_name: String) -> bool {
    let mut return_val = true;
    rotation_array.iter().for_each(|entry| {
        if entry.clone().get(0).unwrap().to_string()  == rotation_name {
            return_val = !(entry.clone().get(3).unwrap().to_string() == "false".to_string());
            return ();
        }
    });
    return_val
}
/// Adds ability to given array
pub fn add_ability_to_array(str_name: String, ability_array: Vec<Vec<String>>, new_array: &mut Vec<Vec<String>>) {
    let mut index_val: isize = -1;
    // Loop through ability
    if !str_name.is_empty() {
        for i in 0..PROFILE_SIZE {
            let abil_str = ability_array[i][0].clone().replace(" ", "");
            // Check if ability array is the one we want
            if abil_str == str_name {
                index_val = i as isize;
            }
            else if ability_array[i][0].is_empty() {
                break;
            }
        }
    }
    // Check if value hasn't changed
    if index_val == -1 {
        return ();
    }
    for j in 0..PROFILE_SIZE {
        if new_array[j][0].is_empty() {
            new_array[j][0] = ability_array[index_val as usize][0].clone();
            new_array[j][1] = ability_array[index_val as usize][1].clone();
            new_array[j][2] = ability_array[index_val as usize][2].clone();
            new_array[j][3] = ability_array[index_val as usize][3].clone();
            new_array[j][4] = ability_array[index_val as usize][4].clone();
            new_array[j][5] = ability_array[index_val as usize][5].clone();
            new_array[j][6] = ability_array[index_val as usize][6].clone();
            new_array[j][7] = ability_array[index_val as usize][7].clone();
            new_array[j][8] = ability_array[index_val as usize][8].clone();
            new_array[j][9] = ability_array[index_val as usize][9].clone();
            return ();
        }
        if new_array[j][0] == str_name {
            return ();
        }
    }
}
/// Return a merged array of rotation + ability
pub fn get_current_array(rotation_array: Vec<Vec<String>>, ability_array: Vec<Vec<String>>, to_load: String) -> Vec<Vec<String>> {
    let mut return_vec = vec![vec![String::default(); 10]; PROFILE_SIZE];
    let mut ability_inp = String::default();
    // Extract ability from rotation
    for i in 0..PROFILE_SIZE {
        if rotation_array[i][0] == to_load {
            ability_inp = rotation_array[i][2].clone();
        }
    }
    // Modify inp
    let modified_ability_inp = ability_inp.as_str().replace(" ", "");
    if modified_ability_inp.is_empty() {
        return return_vec
    }
    // Split all abilities
    let abilities_vec: Vec<String> = modified_ability_inp
        .clone()
        .as_str()
        .split("|")
        .map(|s| s.to_string())
        .collect();
    // Loop through all abilities and add it to array
    abilities_vec.iter().for_each(|ability| {
        let curr_ability = ability.clone().replace(" ", "");
        if !curr_ability.is_empty() {
            add_ability_to_array(curr_ability, ability_array.clone(), &mut return_vec);
        }
    });
    return_vec
}
/// Procedure to initialise bot
pub unsafe fn initialise_bot(wow_proc: WowCheats, rotation_array: Vec<Vec<String>>, ability_array: Vec<Vec<String>>, profile_options: ProfileOptions) {
    // Ungodly scripts...
    let first_load = "\r\n        \r\n        function PQR_Debug(strText)\r\n            if PQR_DebugEnabled == true then\r\n                PQR_WriteToChat(\"[DEBUG] \"..strText);\r\n            end\r\n        end\r\n\r\n        function PQR_SetDebug(enabled)\r\n            if enabled == true then\r\n                PQR_DebugEnabled = true\r\n            else\r\n                PQR_DebugEnabled = false\r\n            end\r\n        end\r\n\r\n        function PQR_WriteToChat(strText)\r\n            if PQR_ShowChat == true then\r\n                print(\"|cffff7d0a<|r|cffffd200PQR|r|cffff7d0a>|r \"..strText)\r\n            end\r\n        end\r\n\r\n        function PQR_EventFrame_OnUpdate(self, elapsed)\r\n\t        PQR_totalElapsed = PQR_totalElapsed + elapsed;\r\n\t        PQR_totalElapsed2 = PQR_totalElapsed2 + elapsed;\r\n            while (PQR_totalElapsed2 > PQR_UpdateInterval2) do\r\n                PQR_RegisterMovement(PQR_totalElapsed2)\r\n                PQR_SetRecastDelay()\r\n                PQR_ExecuteInterrupt()\r\n                PQR_totalElapsed2 = PQR_totalElapsed2 - PQR_UpdateInterval2\r\n            end\r\n            if PQR_ChangeIntervalFlag == 1 then\r\n                PQR_UpdateInterval = PQR_NewInterval\r\n                PQR_ChangeIntervalFlag = 0\r\n                PQR_totalElapsed = 0\r\n            else\r\n                while (PQR_totalElapsed > PQR_UpdateInterval) do\r\n                    PQR_RegisterMovement(PQR_totalElapsed)\r\n                    PQR_SetRecastDelay()\r\n                    PQR_ExecuteBot()\r\n                    PQR_totalElapsed = PQR_totalElapsed - PQR_UpdateInterval\r\n                end\r\n            end\r\n        end\r\n\r\n        function PQR_EventFrame_OnEvent(self,event,...)\r\n            if event == \"PLAYER_ENTERING_WORLD\" then\r\n                PQR_EventFrame:Show()\r\n                SetMapToCurrentZone()\r\n                PQR_Debug(\"Setting Map to Current Zone.\")\r\n            elseif event ==\"PLAYER_REGEN_DISABLED\" then\r\n                SetMapToCurrentZone()\r\n                PQR_Debug(\"Setting Map to Current Zone.\")\r\n            elseif event == \"PLAYER_LOGOUT\" then\r\n                PQR_EnableInterrupt(false)\r\n                PQR_EnableBot(\"\")\r\n            elseif event == \"UNIT_SPELLCAST_FAILED\" then\r\n                local source, spellName = ...\r\n                PQR_DropThreat(\"FAILED\", source, spellName) \r\n            elseif event == \"UNIT_SPELLCAST_FAILED_QUIET\" then\r\n                local source, spellName = ...\r\n                PQR_DropThreat(\"FAILED\", source, spellName) \r\n            elseif event == \"UI_ERROR_MESSAGE\" then\r\n                local errorMessage = ...\r\n                if errorMessage == SPELL_FAILED_NOT_BEHIND then\r\n                    PQR_BehindTime = GetTime()\r\n                elseif errorMessage == SPELL_FAILED_LINE_OF_SIGHT then\r\n                    if PQR_LastTarget ~= nil then\r\n                        if PQR_LastTarget ~= \"none\" and PQR_LastTime > GetTime() - 1 then\r\n                            --LOS message in the last 1 second. Register it.\r\n                            for i=1,10000 do\r\n                                if PQR.losTable.name[i] == nil or PQR.losTable.name[i] == PQR_LastTarget then\r\n                                    --we got to an empty slot in the table\r\n                                    PQR.losTable.name[i] = PQR_LastTarget\r\n                                    PQR.losTable.time[i] = PQR_LastTime\r\n                                    PQR_Debug(\"Added LOS for unit \"..PQR_LastTarget..\" at index \"..i)\r\n                                    break\r\n                                end\r\n                            end\r\n                            PQR_LastTarget = \"none\"\r\n                            PQR_LastTime = 0\r\n                        end\r\n                    end\r\n                end\r\n            elseif event == \"UNIT_SPELLCAST_SUCCEEDED\" then\r\n                local unitCaster, unitSpell, _, _, unitSpellID = ...\r\n                if unitCaster == \"player\" then\r\n                    PQR_SetRecastDelay(unitSpell)\r\n                end\r\n                if unitCaster ~= \"player\" then\r\n                    return\r\n                end\r\n                if unitSpellID ~= 75 then --Auto Shot\r\n                    if unitSpellID == 56641 or unitSpellID == 77767 then --Steady or Cobra\r\n                        PQR_SteadyCount = PQR_SteadyCount + 1\r\n                        PQR_LastCasted = unitSpellID\r\n                    else\r\n                        PQR_SteadyCount = 0\r\n                        PQR_LastCasted = unitSpellID\r\n                    end\r\n                end\r\n            elseif event == \"UNIT_SPELLCAST_SENT\" then\r\n                local unitCaster, unitSpell = ...\r\n                local vanishName = GetSpellInfo(1856)\r\n                local mdName = GetSpellInfo(34477)\r\n                local feignName = GetSpellInfo(5384)\r\n                if unitSpell == vanishName then\r\n                    PQR_DropDelay = GetTime() + 0.5\r\n                end\r\n                if unitSpell == feignName then\r\n                    PQR_DropDelay = GetTime() + 1\r\n                end\r\n                if unitSpell == mdName then\r\n                    PQR_DropDelay = GetTime() + 2.0\r\n                end\r\n            end\r\n        end\r\n        \r\n        function PQR_ExecuteBot()\r\n            --this is the main bot execution function. \r\n            if UnitAffectingCombat ~= nil then\r\n                --make sure we arent at a loading screen, DCd, etc.\r\n \t            PQR_Combat = UnitAffectingCombat(\"player\")\r\n                if PQR_Combat == nil then \r\n                    PQR_Combat = UnitAffectingCombat(\"pet\")\r\n                end\r\n                if PQR_RequireCombat == false and PQR_RotationDesignation == false then\r\n                    PQR_Combat = 1\r\n                end\r\n                if PQR ~= nil then\r\n                    if PQR_RotationDesignation == true and PQR[0].priorityTable.requireCombat == false then\r\n                        PQR_Combat = 1\r\n                    end\r\n                end\r\n                local PQR_ExecuteNext = GetCVar(\"violenceLevel\")\r\n                if tonumber(PQR_ExecuteNext) ~= nil then\r\n                    PQR_ExecuteNext = PQR_ExecuteNext - 5\r\n                    SetCVar(\"violenceLevel\", 2)\r\n                else\r\n                    PQR_ExecuteNext = 0\r\n                end\r\n\r\n                if PQR_ExecuteNext > 0 then\r\n                    --cast the next ability in X queue.\r\n                    PQR_Interrupt()\r\n                    PQR_CastNext(PQR_ExecuteNext)\r\n                else\r\n                    if PQR_ManualMode == false and PQR_BotEnabled == true and PQR_Combat ~= nil then\r\n                        --auto rotation mode is running... execute next.\r\n                        PQR_CastNext(0)\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        function PQR_CastNext(rotation)\r\n            if PQR[rotation] == nil then\r\n                return\r\n            end\r\n\r\n            local nextAbility = PQR_NextAbility(rotation)\r\n            if nextAbility ~= -1 then\r\n\r\n                --Run luaBefore\r\n                PQR[rotation].priorityTable.luaBefore[nextAbility]()\r\n\r\n                --split actions and send RunMacroText\r\n                    if PQR[rotation].priorityTable.actn[nextAbility] ~= \"\" and PQR[rotation].priorityTable.actn[nextAbility] ~= nil then\r\n                        local tbl = { strsplit(\"|\", PQR[rotation].priorityTable.actn[nextAbility]) }\r\n                        for i=1,100 do\r\n                            if tbl[i] == nil then\r\n                                break\r\n                            end\r\n                            if tbl[i] ~= \"\" then\r\n                                PQR_Debug(\"Running Action: \"..tbl[i])\r\n                                RunMacroText(tbl[i])\r\n                            end\r\n                        end\r\n                    end\r\n                --send spell ID\r\n                    local castingID = PQR[rotation].priorityTable.spid[nextAbility]\r\n                    if castingID ~= 0 then\r\n                        local castingName = GetSpellInfo(PQR[rotation].priorityTable.spid[nextAbility])\r\n                        PQR_LastTime = GetTime()\r\n                        if PQR[rotation].priorityTable.targetCast[nextAbility] == \"player\" then\r\n                            PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on PLAYER\")\r\n                            PQR_LastTarget = UnitName(PQR[rotation].priorityTable.targetCast[nextAbility])\r\n                            CastSpellByID(castingID, \"player\")\r\n                        elseif PQR[rotation].priorityTable.targetCast[nextAbility] == \"focus\" then\r\n                  PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on FOCUS\")\r\n                            PQR_LastTarget = UnitName(PQR[rotation].priorityTable.targetCast[nextAbility])\r\n                            CastSpellByID(castingID, \"focus\")\r\n                        elseif PQR[rotation].priorityTable.targetCast[nextAbility] == \"pet\" then\r\n                            PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on PET\")\r\n                            PQR_LastTarget = UnitName(PQR[rotation].priorityTable.targetCast[nextAbility])\r\n                            CastSpellByID(castingID, \"pet\")\r\n                        elseif PQR[rotation].priorityTable.targetCast[nextAbility] == \"mouseover\" then\r\n                            PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on MOUSEOVER\")\r\n                            PQR_LastTarget = UnitName(PQR[rotation].priorityTable.targetCast[nextAbility])\r\n                            CastSpellByID(castingID, \"mouseover\")\r\n                        elseif PQR[rotation].priorityTable.targetCast[nextAbility] == \"click\" then\r\n                            PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on MOUSE LOCATION\")\r\n                            PQR_LastTarget = \"none\"\r\n                            CastSpellByID(castingID)\r\n                            local PQR_TargetName = UnitName(\"target\")\r\n                            CameraOrSelectOrMoveStart()\r\n                            CameraOrSelectOrMoveStop()\r\n                            local PQR_TargetNameNew = UnitName(\"target\")\r\n                            if PQR_TargetName ~= nil then\r\n                                if PQR_TargetName ~= PQR_TargetNameNew then\r\n                                    TargetLastTarget()\r\n                                end\r\n                            end\r\n                        elseif PQR[rotation].priorityTable.targetCast[nextAbility] == \"custom\" then\r\n                            PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on CUSTOM TARGET \"..PQR_CustomTarget)\r\n                            if UnitExists(PQR_CustomTarget) then\r\n                                PQR_LastTarget = UnitName(PQR_CustomTarget)\r\n                                CastSpellByID(castingID, PQR_CustomTarget)\r\n                            else\r\n                                PQR_Debug(\"Custom Target does not exist!\")\r\n                            end\r\n                            PQR_CustomTarget = \"\"\r\n                        else\r\n                            PQR_Debug(\"Casting Spell \"..castingName..\" (\"..castingID..\") on TARGET\")\r\n                            PQR_LastTarget = UnitName(PQR[rotation].priorityTable.targetCast[nextAbility])\r\n                            CastSpellByID(castingID, \"target\")\r\n                        end\r\n                    end\r\n\r\n                --Run luaAfter\r\n                PQR[rotation].priorityTable.luaAfter[nextAbility]()\r\n\r\n            end            \r\n        end\r\n\r\n        function PQR_NextAbility(rotation)    \r\n\t        if PQR[rotation] ~= nil then\r\n\t\t        local _, _, _, _, _, playerChanneling = UnitChannelInfo(\"player\")\r\n\t\t        if playerChanneling ~= nil then\r\n\t\t\t        local currentTime = GetTime() * 1000\r\n\t\t\t        if (playerChanneling - currentTime) > 100 then\r\n                        PQR_IsChanneling = true\r\n                    else\r\n                        PQR_IsChanneling = false\r\n\t\t\t        end\r\n                else\r\n                    PQR_IsChanneling = false\r\n\t\t        end\r\n\r\n\t\t        for i=0,1023 do\r\n\t\t\t        if PQR[rotation].priorityTable.index[i] ~= nil then\r\n                        if PQR_DropDelay <= GetTime() then\r\n\t\t\t\t            if PQR[rotation].priorityTable.spid[i] ~= 0 then\r\n\t\t\t\t\t            if PQR_SpellAvailable(PQR[rotation].priorityTable.spid[i]) == true and PQR[rotation].priorityTable.delay[i] <= (GetTime() * 1000) then\r\n\t\t\t\t\t\t            local PQR_Result = PQR[rotation].priorityTable.test[i]()\r\n\t\t\t\t\t\t            if PQR_Result == true then\r\n                                        if PQR_IsChanneling == true then\r\n                                            if PQR[rotation].priorityTable.cancelChannel[i] == true then\r\n\t\t\t\t\t\t\t                    return i\r\n                                            end\r\n                                        else\r\n                                            return i\r\n                                        end\r\n\t\t\t\t\t\t            end\r\n\t\t\t\t\t            end\r\n\t\t\t\t            else\r\n\t\t\t\t\t            local PQR_Result = PQR[rotation].priorityTable.test[i]()\r\n\t\t\t\t\t\t            if PQR_Result == true then\r\n                                        if PQR_IsChanneling == true then\r\n                                            if PQR[rotation].priorityTable.cancelChannel[i] == true then\r\n\t\t\t\t\t\t\t                    return i\r\n                                            end\r\n                                        else\r\n                                            return i\r\n                                        end\r\n\t\t\t\t\t\t            end\r\n\t\t\t\t            end\r\n                        end\r\n\t\t\t        end\r\n\t\t        end\r\n\t        end\r\n\t        return -1\r\n        end\r\n\r\n        function PQR_ExecuteInterrupt()\r\n            if UnitAffectingCombat ~= nil then\r\n                PQR_Interrupt()\r\n            end\r\n        end\r\n\r\n        function PQR_Interrupt()\r\n            if PQR_InterruptEnabled == false or PQR_InterruptEnabled == nil then\r\n                return\r\n            end\r\n\r\n            if PQR == nil then\r\n                return\r\n            end\r\n\r\n            if PQR.interruptTable == nil then\r\n                return\r\n            end\r\n            \r\n\t\t    if PQR_InterruptTest() == true then\r\n                PQR_Debug(\"Casting Interrupt...\")\r\n\t\t\t    CastSpellByID(PQR_MyInterruptSpell())\r\n\t\t    end\r\n        end\r\n\r\n        function PQR_InterruptTest()\r\n\t        local pq_castingName, _, _, _, pq_castingStartTime, _, _, _, pq_castingInterrupt = UnitCastingInfo(\"target\")\r\n\t        if pq_castingInterrupt ~= nil then\r\n\t\t        if pq_castingInterrupt == true then\r\n\t\t\t        pq_castingInterrupt = false\r\n\t\t        else\r\n\t\t\t        pq_castingInterrupt = true\r\n\t\t        end \r\n\t        end\r\n\r\n\t        local pq_channelName, _, _, _, pq_channelStartTime, _, _, pq_channelInterrupt = UnitChannelInfo(\"target\")\r\n\t        if pq_channelInterrupt ~= nil then\r\n\t\t        pq_castingName = pq_channelName\r\n                pq_castingStartTime = pq_channelStartTime\r\n\t\t        if pq_channelInterrupt == true then\r\n\t\t\t        pq_castingInterrupt = false\r\n\t\t        else\r\n\t\t\t        pq_castingInterrupt = true\r\n\t\t        end\r\n\t        end\r\n\r\n            \r\n\r\n\t        if pq_castingName == nil then\r\n\t\t        pq_castingName = \"\"\r\n\t        end \r\n\r\n\t        if pq_castingInterrupt == nil then\r\n\t\t        pq_castingInterrupt = false\r\n            else\r\n                local PQR_msCastingSpell = GetTime() * 1000 - pq_castingStartTime\r\n                if PQR_msCastingSpell < PQR_InterruptDelay then\r\n                    pq_castingInterrupt = false\r\n                end\r\n\t        end\r\n\r\n            if UnitCanAttack(\"player\", \"target\") == nil then\r\n                --we cannot attack/interrupt the target.\r\n                pq_castingInterrupt = false\r\n            end\r\n          \r\n\t        local PQR_CastInterrupt = false\r\n\t        if pq_castingInterrupt == true then\r\n\t\t        local _, InterruptCD, _ = GetSpellCooldown(PQR_MyInterruptSpell())\r\n\t\t        if InterruptCD == 0 then\r\n\t\t\t        if PQR_InterruptAllSpells == true then\r\n\t\t\t\t        PQR_CastInterrupt = true\r\n\t\t\t        end\r\n\t\t\t\r\n\t\t\t        for i=0,1023 do\r\n\t\t\t\t        --check to see if any abilities need to be cast.\r\n\t\t\t\t        if PQR.interruptTable.spell[i] ~= nil then\r\n\t\t\t\t\t        if strupper(PQR.interruptTable.spell[i]) == strupper(pq_castingName) then\r\n\t\t\t\t\t\t        PQR_CastInterrupt = true\r\n                                break\r\n\t\t\t\t\t        end\r\n\t\t\t\t        else\r\n\t\t\t\t\t        break\r\n\t\t\t\t        end\r\n\t\t\t        end\r\n\t\t        end\r\n\t        end\r\n\t\r\n\t        if PQR_CastInterrupt == true then\r\n\t\t        return true\r\n\t        else\r\n\t\t        return false\r\n\t        end\r\n        end\r\n\r\n        function PQR_MyInterruptSpell()\r\n\t        if UnitClass ~= nil then\r\n\t\t        local _, PQR_UnitClass = UnitClass(\"player\")\r\n\t\t\r\n\t\t        if PQR_UnitClass == \"DEATHKNIGHT\" then\r\n\t\t\t        return 47528\r\n\t\t        elseif PQR_UnitClass == \"DRUID\" then\r\n\t\t\t        local catForm = UnitBuffID(\"player\", 768)\r\n\t\t\t        if catForm ~= nil then\r\n\t\t\t\t        return 80965\r\n\t\t\t        else\r\n\t\t\t\t        return 80964\r\n\t\t\t        end\r\n\t\t        elseif PQR_UnitClass == \"HUNTER\" then\r\n\t\t\t        return 34490\r\n\t\t        elseif PQR_UnitClass == \"MAGE\" then\r\n\t\t\t        return 2139\r\n\t\t        elseif PQR_UnitClass == \"PALADIN\" then\r\n\t\t\t        return 96231\r\n\t\t        elseif PQR_UnitClass == \"PRIEST\" then\r\n\t\t\t        return 15487\r\n\t\t        elseif PQR_UnitClass == \"ROGUE\" then\r\n\t\t\t        return 1766\r\n\t\t        elseif PQR_UnitClass == \"SHAMAN\" then\r\n\t\t\t        return 57994\r\n\t\t        elseif PQR_UnitClass == \"WARLOCK\" then\r\n\t\t\t        return 19647\r\n\t\t        elseif PQR_UnitClass == \"WARRIOR\" then\r\n\t\t\t        return 6552\r\n\t\t        else\r\n\t\t\t  return 0\r\n\t\t        end\r\n\t        else\r\n\t\t        return 0\r\n\t        end\r\n        end\r\n\r\n        function PQR_SetRecastDelay(manualSpellName)\r\n           \r\n           local PQR_CurrentSpellName = UnitCastingInfo(\"player\")\r\n           if PQR_CurrentSpellName == nil then\r\n                PQR_CurrentSpellName = UnitCastingInfo(\"player\")\r\n            end \r\n            if manualSpellName ~= nil then\r\n                PQR_CurrentSpellName = manualSpellName\r\n            end\r\n            if PQR_CurrentSpellName == nil then\r\n                return\r\n            end\r\n            PQR_Debug(\"SetRecastDelay called for spell: \"..PQR_CurrentSpellName)\r\n\r\n            if PQR_ManualMode == false and PQR_BotEnabled == true then\r\n                --PQR[0]\r\n                for i=0,1023 do\r\n                    if PQR[0].priorityTable.index[i] == nil then\r\n                        break\r\n                    else\r\n                        if PQR[0].priorityTable.spid[i] ~= 0 then\r\n                            local PQR_LookupSpell = GetSpellInfo(PQR[0].priorityTable.spid[i])\r\n                            if PQR_LookupSpell == PQR_CurrentSpellName then\r\n                                PQR[0].priorityTable.delay[i] = (GetTime() * 1000) + PQR[0].priorityTable.recast[i]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            else\r\n                --PQR[1]\r\n                for i=0,1023 do\r\n                    if PQR[1].priorityTable.index[i] == nil then\r\n                        break\r\n                    else\r\n                        if PQR[1].priorityTable.spid[i] ~= 1 then\r\n                            local PQR_LookupSpell = GetSpellInfo(PQR[1].priorityTable.spid[i])\r\n                            if PQR_LookupSpell == PQR_CurrentSpellName then\r\n                                PQR[1].priorityTable.delay[i] = (GetTime() * 1000) + PQR[1].priorityTable.recast[i]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n\r\n                --PQR[2]\r\n                for i=0,1023 do\r\n                    if PQR[2].priorityTable.index[i] == nil then\r\n                        break\r\n                    else\r\n                        if PQR[2].priorityTable.spid[i] ~= 2 then\r\n                            local PQR_LookupSpell = GetSpellInfo(PQR[2].priorityTable.spid[i])\r\n                            if PQR_LookupSpell == PQR_CurrentSpellName then\r\n                                PQR[2].priorityTable.delay[i] = (GetTime() * 1000) + PQR[2].priorityTable.recast[i]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n\r\n                --PQR[3]\r\n                for i=0,1023 do\r\n                    if PQR[3].priorityTable.index[i] == nil then\r\n                        break\r\n                    else\r\n                        if PQR[3].priorityTable.spid[i] ~= 3 then\r\n                            local PQR_LookupSpell = GetSpellInfo(PQR[3].priorityTable.spid[i])\r\n                            if PQR_LookupSpell == PQR_CurrentSpellName then\r\n                                PQR[3].priorityTable.delay[i] = (GetTime() * 1000) + PQR[3].priorityTable.recast[i]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n\r\n                --PQR[4]\r\n                for i=0,1023 do\r\n                    if PQR[4].priorityTable.index[i] == nil then\r\n                        break\r\n                    else\r\n                        if PQR[4].priorityTable.spid[i] ~= 4 then\r\n                            local PQR_LookupSpell = GetSpellInfo(PQR[4].priorityTable.spid[i])\r\n                            if PQR_LookupSpell == PQR_CurrentSpellName then\r\n                                PQR[4].priorityTable.delay[i] = (GetTime() * 1000) + PQR[4].priorityTable.recast[i]\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n        end\r\n\r\n        if PQR_EventFrame == nil then\r\n            PQR = {}\r\n            PQR.interruptTable = {}\r\n            PQR.interruptTable.spell = {}\r\n            for i=0,4 do\r\n                PQR[i] = {}\r\n            end\r\n            PQR_RotationDesignation = true\r\n            PQR_ManualMode = false\r\n            PQR_totalElapsed = 0.0\r\n            PQR_totalElapsed2 = 0.0\r\n            PQR_SteadyCount = 0\r\n            PQR_LastCasted = 0\r\n            PQR_DropDelay = 0\r\n            PQR_ChangeIntervalFlag = 0\r\n            PQR_NewInterval = 0.1\r\n            PQR_UpdateInterval = 0.1\r\n            PQR_UpdateInterval2 = 0.1\r\n            PQR_BehindTime = 0\r\n            PQR_CurrentX = 0\r\n            PQR_CurrentY = 0\r\n            PQR_StationaryX = 0\r\n            PQR_StationaryY = 0\r\n            PQR_StationaryTime = 0\r\n            PQR_CurrentMovingTime = 0\r\n            PQR_CurrentStationaryTime = 1\r\n            PQR_ResetMovementTime = 1\r\n            PQR_LastMovementTime = 0\r\n            PQR_RequireCombat = true\r\n            PQR_InterruptDelay = 0\r\n            PQR_IsChanneling = false\r\n            PQR_LastTarget = \"none\"\r\n            PQR_LastTime = 0\r\n            PQR_CustomTarget = \"\"\r\n            PQR_EventFrame = CreateFrame(\"Frame\")\r\n            PQR_EventFrame:RegisterEvent(\"COMBAT_LOG_EVENT_UNFILTERED\")\r\n            PQR_EventFrame:RegisterEvent(\"PLAYER_ENTERING_WORLD\")\r\n            PQR_EventFrame:RegisterEvent(\"UNIT_SPELLCAST_SENT\")\r\n            PQR_EventFrame:RegisterEvent(\"PLAYER_LOGOUT\")\r\n            PQR_EventFrame:RegisterEvent(\"UNIT_SPELLCAST_FAILED\")\r\n            PQR_EventFrame:RegisterEvent(\"UNIT_SPELLCSAT_FAILED_QUIET\")\r\n            PQR_EventFrame:RegisterEvent(\"UI_ERROR_MESSAGE\")\r\n            PQR_EventFrame:RegisterEvent(\"UNIT_SPELLCAST_SUCCEEDED\")\r\n            PQR_EventFrame:RegisterEvent(\"PLAYER_REGEN_DISABLED\")\r\n            PQR_EventFrame:SetScript(\"OnUpdate\", PQR_EventFrame_OnUpdate)\r\n            PQR_EventFrame:SetScript(\"OnEvent\", PQR_EventFrame_OnEvent)\r\n            PQR_EventFrame:Show()\r\n        end\r\n\r\n\r\n\r\n        function PQR_RegisterMovement(elapsed)\r\n            local posX, posY = GetPlayerMapPosition(\"player\")\r\n            local playerMovementSpeed = GetUnitSpeed(\"player\")\r\n\r\n            if playerMovementSpeed ~= 0 then\r\n                PQR_CurrentMovingTime = PQR_CurrentMovingTime + elapsed\r\n                PQR_CurrentStationaryTime = 0\r\n            else\r\n                if PQR_CurrentStationaryTime < PQR_ResetMovementTime then\r\n                    PQR_CurrentStationaryTime = PQR_CurrentStationaryTime + elapsed\r\n                end\r\n                if PQR_CurrentStationaryTime > PQR_ResetMovementTime then\r\n                    PQR_CurrentMovingTime = 0\r\n                end\r\n            end\r\n         end\r\n\r\n        function PQR_EnableInterrupt(disable)\r\n            if PQR_InterruptEnabled == true then\r\n                PlaySound(PQR_StopInterruptSound, \"Master\")\r\n                PQR_WriteToChat(\"Interrupt Mode Disabled.\")\r\n                PQR_InterruptEnabled = false\r\n            else\r\n                if disable == nil then\r\n                    PlaySound(PQR_StartInterruptSound, \"Master\")\r\n                    PQR_WriteToChat(\"Interrupt Mode Enabled.\")\r\n                    PQR_InterruptEnabled = true\r\n                else\r\n                    if disable == true and PQR_InterruptEnabled == true then\r\n                        PlaySound(PQR_StopInterruptSound, \"Master\")\r\n                        PQR_WriteToChat(\"Interrupt Mode Disabled.\")\r\n                    end\r\n                    PQR_InterruptEnabled = false\r\n                end\r\n            end\r\n        end\r\n\r\n        function PQR_EnableBot(mode)\r\n            --This function will display the proper chat message regarding if the bot is switching modes or is enabling/disabling.\r\n            PQR_ResetMovementTime = 1.0\r\n            if (mode ~= PQR_BotRotation) then\r\n                if mode == \"\" then\r\n                    PlaySound(PQR_StopRotationSound, \"Master\")\r\n                    PQR_WriteToChat(\"Rotation Mode Disabled.\")\r\n                    PQR_BotRotation = \"\"\r\n                    PQR_BotEnabled = false\r\n                else\r\n                    if PQR_BotRotation == \"\" or PQR_BotRotation == nil then\r\n                        PlaySound(PQR_StartRotationSound, \"Master\")\r\n                    else\r\n                        PlaySound(PQR_ChangeRotationSound, \"Master\")\r\n                    end\r\n                    local PQR_CorrectMode = strsplit(\"^&*\", mode)\r\n                    PQR_WriteToChat(PQR_CorrectMode..\" Rotation Mode Enabled.\")\r\n                    SetMapToCurrentZone()\r\n                    PQR_BotRotation = mode\r\n                    PQR_BotEnabled = true\r\n                end\r\n            else\r\n                if (mode == \"* Manual\") then\r\n                    PQR_WriteToChat(mode..\" Rotation Mode Enabled.\")\r\n                    PQR_BotRotation = mode\r\n                    PQR_BotEnabled = true\r\n                else\r\n                    PlaySound(PQR_StopRotationSound, \"Master\")\r\n                    PQR_WriteToChat(\"Rotation Mode Disabled.\")\r\n                    PQR_BotRotation = \"\"\r\n                    PQR_BotEnabled = false\r\n                end\r\n            end\r\n        end\r\n\r\n        function PQR_ChangeInterval(newInterval)\r\n            PQR_Debug(\"Changing Interval to: '\"..newInterval..\"'\")\r\n            if newInterval >= 20 and newInterval <= 1000 then\r\n                PQR_NewInterval = (newInterval / 1000)\r\n            else\r\n                PQR_NewInterval = 0.1\r\n            end\r\n            PQR_ChangeIntervalFlag = 1\r\n        end\r\n\r\n        function PQR_DropThreat(successType, spellCaster, spellName)\r\n            if spellCaster == \"player\" and PQR_isThreatDrop(spellName) == true then\r\n\t\t        if successType == \"SUCCESS\" then\r\n\t\t\t        PQR_DropDelay = 0\r\n\t\t        elseif successType == \"FAILED\" then\r\n\t\t\t        --player is attempting to drop threat but failing due to being on GCD. Delay any future updates for .5 seconds so player can drop threat.\r\n\t\t\t        \r\n\t\t\t        local start, duration, enabled = GetSpellCooldown(spellName);\r\n\t\t\t        local dropthreatCD = (start + duration - GetTime())\r\n\t\t\t\r\n\t\t\t        if dropthreatCD <= 5 then\r\n                        PQR_DropDelay = GetTime() + 0.5\r\n\t\t\t        end\r\n\t\t        end\r\n            end\r\n        end\r\n\r\n        function PQR_isThreatDrop(spellName)\r\n            if PQTD == nil then\r\n                PQTD = {}\r\n            end\r\n            PQTD[1] = GetSpellInfo(5384) --Feign Death\r\n            PQTD[2] = GetSpellInfo(642) --Divine Shield\r\n            PQTD[3] = GetSpellInfo(12042) --Arcane Power\r\n            PQTD[4] = GetSpellInfo(66) --Invisibility\r\n            for i=1,3 do\r\n                if PQTD[i] == spellName then\r\n                    return true\r\n                end\r\n            end\r\n            return false\r\n        end        \r\n\r\n        function PQR_GCDSpell()\r\n\t        if UnitClass ~= nil then\r\n\t\t        local _, PQR_UnitClass = UnitClass(\"player\")\r\n                local _, build = GetBuildInfo()\r\n                if tonumber(build) <= 2973 then\r\n\t\t            if PQR_UnitClass == \"DEATHKNIGHT\" then\r\n\t\t\t            return 52375\r\n\t\t            elseif PQR_UnitClass == \"DRUID\" then\r\n\t\t\t            return 774\r\n\t\t            elseif PQR_UnitClass == \"HUNTER\" then\r\n\t\t\t            return 56641\r\n\t\t            elseif PQR_UnitClass == \"MAGE\" then\r\n\t\t\t            return 1459\r\n\t\t            elseif PQR_UnitClass == \"PALADIN\" then\r\n\t\t\t            return 85256\r\n\t\t            elseif PQR_UnitClass == \"PRIEST\" then\r\n\t\t\t            return 2050\r\n\t\t            elseif PQR_UnitClass == \"ROGUE\" then\r\n\t\t\t            return 1752\r\n\t\t            elseif PQR_UnitClass == \"SHAMAN\" then\r\n\t\t\t            return 45284\r\n\t\t            elseif PQR_UnitClass == \"WARLOCK\" then\r\n\t\t\t            return 980\r\n\t\t            elseif PQR_UnitClass == \"WARRIOR\" then\r\n\t\t\t            return 1715\r\n\t\t            else\r\n\t\t\t            return 0\r\n\t\t            end\r\n                else\r\n\t\t            if PQR_UnitClass == \"DEATHKNIGHT\" then\r\n\t\t\t            return 52375\r\n\t\t            elseif PQR_UnitClass == \"DRUID\" then\r\n\t\t\t            return 774\r\n\t\t            elseif PQR_UnitClass == \"HUNTER\" then\r\n\t\t\t            return 56641\r\n\t\t            elseif PQR_UnitClass == \"MAGE\" then\r\n\t\t\t            return 1459\r\n\t\t            elseif PQR_UnitClass == \"PALADIN\" then\r\n\t\t\t            return 85256\r\n\t\t            elseif PQR_UnitClass == \"PRIEST\" then\r\n\t\t\t            return 2050\r\n\t\t            elseif PQR_UnitClass == \"ROGUE\" then\r\n\t\t\t            return 1752\r\n\t\t            elseif PQR_UnitClass == \"SHAMAN\" then\r\n\t\t\t            return 45284\r\n\t\t            elseif PQR_UnitClass == \"WARLOCK\" then\r\n\t\t\t            return 980\r\n\t\t            elseif PQR_UnitClass == \"WARRIOR\" then\r\n\t\t\t            return 1715\r\n\t\t            else\r\n\t\t\t            return 0\r\n\t\t            end\r\n                end\r\n\t        else\r\n\t\t        return 0\r\n\t        end\r\n        end\r\n\r\n        function PQR_SpellAvailable(SpellID)\r\n\t        local GCDSpell = PQR_GCDSpell()\r\n\r\n\t        if GetSpellCooldown ~= nil then\r\n\t\t        local GCDstartTime, GCDduration = GetSpellCooldown(GCDSpell)\r\n\t\t        local startTime, duration, enabled = GetSpellCooldown(SpellID)\r\n\t\t        local usableName, _, _, spellCost = GetSpellInfo(SpellID)\r\n                local spellUsable = nil\r\n                local _, build = GetBuildInfo()\r\n                if tonumber(build) <= 12340 then\r\n\t\t            spellUsable = IsUsableSpell(usableName)\r\n                else\r\n                    spellUsable = IsUsableSpell(SpellID)\r\n                end\r\n\t\t        pq_SpellAvailable = \"false\"\r\n        \r\n\t\t        if startTime ~= nil and GCDstartTime ~= nil then\r\n\t\t\t        local timeLeft = startTime + duration - GetTime()\r\n\t\t\t        local GCDtimeLeft = GCDstartTime + GCDduration - GetTime()\r\n\t\t\t\t        if GCDtimeLeft <= 0 then\r\n\t\t\t\t\t        if timeLeft <= .25 then\r\n\t\t\t\t\t\t        if spellUsable ~= nil then\r\n\t\t\t\t\t\t\t        pq_SpellAvailable = \"true\"\r\n\t\t\t\t\t\t        end\r\n\t\t\t\t\t        end\r\n\t\t\t\t        else\r\n\t\t\t\t\t        if timeLeft <= GCDtimeLeft + 0.25 then\r\n\t\t\t\t\t\t        if spellUsable ~= nil then\r\n\t\t\t\t\t\t\t        pq_SpellAvailable = \"true\"\r\n\t\t\t\t\t\t        end\r\n\t\t\t\t\t        end\r\n\t\t\t\t        end\r\n\t\t        else\r\n\t\t\t        pq_SpellAvailable = \"false\"\r\n\t\t        end\r\n\t        else\r\n\t\t        pq_SpellAvailable = \"false\"\r\n\t        end\r\n\t\r\n\t        if pq_SpellAvailable == nil or pq_SpellAvailable == \"false\" then\r\n\t\t        return false\r\n\t        else\r\n\t\t        return true\r\n\t        end\r\n        end\r\n\r\n";
    let scripting_functions = "\r\n        function PQR_IsCastingSpell(spellID)\r\n            local spellName = GetSpellInfo(spellID)\r\n            local spellCasting = UnitCastingInfo(\"player\")\r\n                if spellCasting == nil then\r\n                    spellCasting = UnitChannelInfo(\"player\")\r\n                end\r\n                if spellCasting == spellName then\r\n                    return true\r\n                else\r\n                    return false\r\n                end\r\n        end\r\n\r\n        function PQR_NotBehindTarget()\r\n            if PQR_BehindTime + 3 > GetTime() then\r\n                return true\r\n            else\r\n                return false\r\n            end\r\n        end\r\n\r\n        function PQR_IsMoving(seconds) \r\n            local PQR_MoltenFeathers = UnitBuffID(\"player\", 98767)\r\n            if PQR_CurrentMovingTime >= seconds and PQR_MoltenFeathers == nil then\r\n                return true\r\n            else\r\n                return false\r\n            end\r\n        end\r\n\r\n        function PQR_IsOutOfSight(unit, seconds)\r\n            local secondsCheck = seconds\r\n            if secondsCheck == nil then\r\n                secondsCheck = 3\r\n            end\r\n            local unitCheck = unit\r\n            if unitCheck == nil then\r\n                unitCheck = \"target\"\r\n            end\r\n            local PQR_TargetName = UnitName(unitCheck)\r\n\r\n            if PQR_TargetName ~= nil then\r\n                for i=1,10000 do\r\n                    if PQR.losTable.name[i] == nil then\r\n                        return false\r\n                    end\r\n                    if PQR.losTable.name[i] == PQR_TargetName then\r\n                        if PQR.losTable.time[i] > GetTime() - secondsCheck then\r\n                            return true\r\n                        else\r\n                            return false\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n            return false\r\n        end\r\n\r\n        function UnitBuffID(unit, spellID, filter)\r\n\t        local spellName = GetSpellInfo(spellID)\r\n\t        if filter == nil then\r\n\t\t        return UnitBuff(unit, spellName)\r\n\t        else\r\n\t\t        return UnitBuff(unit, spellName, nil, filter)\r\n\t        end\r\n        end\r\n\r\n        function UnitDebuffID(unit, spellID, filter)\r\n\t        local spellName = GetSpellInfo(spellID)\r\n\t        if filter == nil then\r\n\t\t        return UnitDebuff(unit, spellName)\r\n\t        else\r\n\t\t        return UnitDebuff(unit, spellName, nil, filter)\r\n\t        end\r\n        end\r\n";
    let clear_tables = "PQR_SetupTables()";
    let table_setup = " \r\n        function PQR_SetupTables()\r\n            PQR = {}\r\n            for i=0,4 do\r\n                PQR[i] = {}\r\n                PQR[i].priorityTable = {}\r\n\t\t        PQR[i].priorityTable.index = {}\r\n\t\t        PQR[i].priorityTable.spid = {}\r\n\t\t        PQR[i].priorityTable.actn = {}\r\n\t\t        PQR[i].priorityTable.test = {}\r\n                PQR[i].priorityTable.recast = {}\r\n                PQR[i].priorityTable.targetCast = {}\r\n                PQR[i].priorityTable.delay = {}\r\n                PQR[i].priorityTable.cancelChannel = {}\r\n                PQR[i].priorityTable.requireCombat = true\r\n                PQR[i].priorityTable.luaBefore = {}\r\n                PQR[i].priorityTable.luaAfter = {}\r\n\t\t        PQR.interruptTable = {}\r\n\t\t        PQR.interruptTable.spell = {}\r\n                PQR.losTable = {}\r\n                PQR.losTable.name = {}\r\n                PQR.losTable.time = {}\r\n            end\r\n        end\r\n\r\n        function PQR_AddAbility(rotationNumber, index, spid, actn, testCode, recastDelay, targetCast, cancelChannel, luaBefore, luaAfter)\r\n\t\t    PQR[rotationNumber].priorityTable.index[index] = index\r\n\t\t    PQR[rotationNumber].priorityTable.spid[index] = spid\r\n\t\t    PQR[rotationNumber].priorityTable.actn[index] = actn\r\n\t\t    PQR[rotationNumber].priorityTable.test[index] = testCode\r\n            PQR[rotationNumber].priorityTable.recast[index] = recastDelay\r\n            PQR[rotationNumber].priorityTable.targetCast[index] = targetCast\r\n            PQR[rotationNumber].priorityTable.delay[index] = rotationNumber\r\n            PQR[rotationNumber].priorityTable.cancelChannel[index] = cancelChannel\r\n            PQR[rotationNumber].priorityTable.luaBefore[index] = luaBefore\r\n            PQR[rotationNumber].priorityTable.luaAfter[index] = luaAfter\r\n        end\r\n\r\n        function PQR_AddInterrupt(spellName)\r\n            for i=0,1023 do\r\n\t\t\t    if PQR.interruptTable.spell[i] == nil then\r\n\t\t\t        PQR.interruptTable.spell[i] = spellName\r\n                    return\r\n\t\t\t    end\r\n            end\r\n        end\r\n";
    // Call dostring with a replacement of PQR with a run-time-randomly-generated string
    wow_proc.second_run_string(first_load);
    wow_proc.second_run_string(scripting_functions);
    wow_proc.second_run_string(table_setup);
    wow_proc.second_run_string(clear_tables);
    // get profile name
    let full_profile_name = rotation_array[0][0].clone();
   //let full_profile_name = format!("{profile_name}({})", profile_name.replace(" ", ""));
    // Add abilities to lib
    let current_rotation = get_current_array(rotation_array.clone(), ability_array.clone(), full_profile_name.clone());
    let mut full_ability_str = "".to_string();
    for j in 0..PROFILE_SIZE {
        if !current_rotation[j][0].is_empty() {
            full_ability_str = format!("{full_ability_str} {}",
                                       add_ability("0".to_string(),
                                                   j.to_string(),
                                                   current_rotation[j][2].clone(),
                                                   current_rotation[j][3].clone(),
                                                   current_rotation[j][4].clone(),
                                                   current_rotation[j][5].clone(),
                                                   current_rotation[j][6].clone(),
                                                   current_rotation[j][7].clone(),
                                                   current_rotation[j][8].clone(),
                                                   current_rotation[j][9].clone()
                                       )
            );
        }
    }
    // Add to PQR table
    full_ability_str = format!("{full_ability_str} PQR[0].priorityTable.requireCombat = {}", rotation_requires_combat(rotation_array, full_profile_name.clone()));
    // Execute all strings
    wow_proc.second_run_string(full_ability_str.as_str());
    let pre_start_string = pqr_pre_start_up(
        profile_options.show_chat,
        profile_options.enable_debug,
        profile_options.require_combat,
        true,
        profile_options.refresh_rate,
        profile_options.interrupt_delay
    ) + format!(" {}", cast_next_func("PQR_SmartHotkey".to_string())).as_str();
    wow_proc.second_run_string(pre_start_string.as_str());
    wow_proc.second_run_string(start_op_bot(
        profile_options.enable_interrupt,
        true,
        true,
        false,
        true,
        full_profile_name).as_str());
}